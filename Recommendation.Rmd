---
title: "Пример рекомендательной системы"
output: html_document
---

Сегодня мы рассмотрим пример построения небольшой рекомендательной системы в R.

Используем пакет  `recommenderlab`

```{r message=FALSE, warning=FALSE}
library(recommenderlab)
```

Построим систему, которая будет рекомендовать фильмы на основе базы оценок. В качестве исходных данных используем датасет MovieLense

```{r}
data(MovieLense)
MovieLense
```

Каждая строчка соответствует пользователю, столбец -- фильму, на пересечении -- оценки. Однако в полной матрице 943*1664 было бы слишком много пропущенных значений (каждый пользователь оценивает существенно меньше фильмов, чем есть в датасете). Поэтому используется более компактный способ хранения.

*Обратите внимание* -- датасет хранится в объекте класса realRatingMatrix, а не data.frame или matrix. Поэтому есть особенности работы с такими данными, например, ряд специальных функций именно для рекомендательных систем.

Для построения рекомендаций применим метод коллаборативной фильтрации. Этот метод основан на использовании оценок «похожих» людей. Похожесть (similarity) может определяться разными способами

* Коэффициент Пирсона;
* Косинусное расстояние;
* Евклидово расстояние.

Рассмотрим, например, похожесть первых 10 пользователей

```{r}
similarity_users10 <- similarity(MovieLense[1:10, ], method = "cosine", which = "users")
as.matrix(similarity_users10)
```

Или в виде графика (уже рассмотренной ранее heatmap)

```{r}
image(as.matrix(similarity_users10), main = "User similarity")
```

Таким же образом можно посчитать и схожесть между фильмами

### Построение рекомендательной модели

Сначала подготовим данные, в частности, уберем те, что являются нерелевантными. 

Если фильм редкий, его мало кто видел, то оценки для него могут быть сильно смщенными. Так же и для пользователя -- если он оценил малое число фильмов, то ему сложно дать рекомендацию. 

Как определить, что является "малым числом"? В общем случае -- итерационно, т.е. отбираем данные, строим модель, оцениваем ее и так несколько раз. В данном примере рассмотрим только один шаг -- будем считать, что нас интересуют фильмы с не менее 100 оценками и пользователи, поставившие не менее 50 оценок.

Количество оценок у фильма можно посчитать с помощью функции colCounts(), а количество оценок, поставленных одним пользователем -- с помощью rowCounts(). Эти функции не учитывают 0, которыми обозначены отстутствющие оценки.

```{r}
library(ggplot2)
ggplot(data = data.frame(filmRate=colCounts(MovieLense))) + geom_histogram(aes(x=filmRate))

ggplot(data = data.frame(userRate=rowCounts(MovieLense))) + geom_histogram(aes(x=userRate))
```

Отберем только строки и столбцы с нужным количеством оценок

```{r}
ratings_movies <- MovieLense[rowCounts(MovieLense) > 50,
colCounts(MovieLense) > 100] 
ratings_movies
```

Рассмотрим распределение средних оценок пользователя

```{r}
average_ratings_per_user <- rowMeans(ratings_movies)
ggplot()+geom_histogram(aes(x=average_ratings_per_user)) +
ggtitle("Распределение средних оценок пользователей")
```

Метод коллаборативной фильтрации

* вычислить похожесть всех пар фильмов
* для каждого фильма найти k наиболее похожих
* для каждого пользователя определить фильмы, наиболее близкие к тем, которые он оценил

Разделим данные на тестовую и обучающую выборки. На обучающей построим модель, для пользователей из тестовой будем рекомендовать фильмы.

```{r}
set.seed(100)
test_ind <- sample(1:nrow(ratings_movies), size = nrow(ratings_movies)*0.2)
recc_data_train <- ratings_movies[-test_ind, ]
recc_data_test <- ratings_movies[test_ind, ]
```

Возможны разные методы построения модели. Рассмотрим метод IBCF ("Recommender based on item-based collaborative filtering (real
data).")

Параметры этого метода по умолчанию
```{r}
recommender_models <- recommenderRegistry$get_entries(dataType =
"realRatingMatrix")
recommender_models$IBCF_realRatingMatrix$parameters
```

Построим рекомендательную модель
```{r}
recc_model <- Recommender(data = recc_data_train, method = "IBCF",
parameter = list(k = 30))
recc_model
```

Детали этой модели можно получить с помощью метода getModel(), например, матрицу схожести

```{r}
model_details <- getModel(recc_model)
model_details$description
model_details$sim[1:5, 1:5]
```

Рекомендации

* для каждого пользователя извлекаются те фильмы, которые он оценил
* для каждого из фильмов находятся похожие фильмы
* затем фильмы упорядочиваются согласно весам, где вес каждой рекомендации (фильма) вычисляется на основе оценок пользователя и показателей схожести фильмов (взвешенная сумма)

```{r}
recc_predicted <- predict(object = recc_model, newdata = recc_data_test, n = 6)
recc_predicted
```

Посмотрим на результат
```{r}
str(recc_predicted)
```

Слоты (доступ через символ @) 

* items -- содержит индексы рекомендованных фильмов для каждого пользователя
* itemLabels -- названия фильмов
* ratings -- рейтинги рекомендаций
* n -- число рекомендаций

Рекомендации для первого пользователя
```{r}
recc_user_1 <- recc_predicted@items[[1]]
recc_user_1
movies_user_1 <- recc_predicted@itemLabels[recc_user_1]
movies_user_1
```

Общая матрица рекомендаций для пользователей
```{r}
recc_matrix <- sapply(recc_predicted@items, function(x){
colnames(ratings_movies)[x]
})
dim(recc_matrix)
```

**Ваша очередь:**

Постройте рекомендательную систему на основе схожести между пользователями, а не между фильмами (метод UBCF вместо IBCF).